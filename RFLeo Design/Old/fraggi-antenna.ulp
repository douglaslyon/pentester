// minimum Eagle version required for this script
#require 4.1106
#include "fractenna-utils.ulp"



//
// gromero@felingeneering.com
//
//--------------------------------------------------------------------------------------

// parameters
int par_add_dimensions = 1;

int par_levels = 4;//3;
real par_padding = 10; // mm
real par_width = 50; //mm
real par_height = 50 ; //mm
real par_trace_width = 8; // mils
real par_pad_diameter = 0.6; //mm
real par_pad_drill = 0.4; // mm
real par_connector_length = 0.0; //mm
int par_connect_to_center = 0; // 0 = center / 1 = edge
real par_split_ratio = 0.2;
int par_multiscale = 1;

// Eagle doesn't have user-defined structures and doesn't support recursivity,
// so we'll need to use several parallel stacks.
real stk_x1[];
real stk_y1[];
real stk_x2[];
real stk_y2[];
real stk_level[];
real stk_dir[];
int  stk_elements;


//--------------------------------------------------------------------------------------

// push a triangle into the triangles stack
void pushCross(int level, real x1, real y1, real x2, real y2, int dir) {
	stk_x1[stk_elements] =x1;
	stk_y1[stk_elements] =y1;
	stk_x2[stk_elements] =x2;
	stk_y2[stk_elements] =y2;
	stk_level[stk_elements] = level;
	stk_dir[stk_elements] = dir;
	stk_elements++;
}

// intitialize the cross stack with a single cross of the size of the whole
// antenna.
void initStack(void) {
	real shift;
	real w2;
	real h2;
	real orig_x;
	real orig_y;

	if (par_connect_to_center) {
		shift = max(par_connector_length - max(par_width, par_height)/2.0, 0);
		w2 = par_width / 2.0;
		h2 = par_height / 2.0;
		orig_x = shift + w2;
		orig_y = shift + h2;
	} else {
		w2 = par_width / 2.0;
		h2 = par_height / 2.0;
		orig_x = w2;
		orig_y = h2 + par_connector_length;
	}



	stk_elements = 0;
	pushCross(1,
			orig_x-w2, orig_y-h2,
			orig_x+w2, orig_y+h2, 0);
}

// This function iterates popping and inserting crosses on the stack.
// Every iteration, one cross is popped from the stack. If it needs to be subdivided,
// then it is split into five crosses which are then pushed back into the stack.
// Otherwise the popped cross is output to the board or library editor.
void buildAntenna(void) {
	real x1,x2,x3,x4,x5,x6;
	real y1,y2,y3,y4,y5,y6;
	real t1, t2;
	int i;
	int level;
	int dir;
	real len;
	real ratio;
	string info;
	real min_size = par_trace_width * 0.0254 * 2; // twice the wire size (mils -> mm)
	initStack();

	real size = max(par_width, par_height);
	real d =  par_split_ratio * size / 2.5; // spacing between tips in first iteration

	while (stk_elements > 0) {
		i = --stk_elements;
		x1 = stk_x1[i];
		x6 = stk_x2[i];
		y1 = stk_y1[i];
		y6 = stk_y2[i];

		// if cross is at the last level, we output it
		if (stk_level[i] >= par_levels /* || (x6-x1)< min_size || (y6-y1)< min_size*/) {
			placeCross(x1, y1, x6, y6);
		} else {

			ratio = d / max(x6-x1, y6-y1);
			t1 = (1.0/3.0 - 1.0/4.0) * ratio + 1.0/4.0;
			t2 = (1.0/3.0 - 1.0/2.0) * ratio + 1.0/2.0;
			// split the triangle into three smaller triangles,
			// and push them into the stack
			level = stk_level[i];
			dir = stk_dir[i];
	
			// corners of the original triangle
			x2 = (x6 - x1) * t1 + x1;
			x3 = (x6 - x1) * t2 + x1;
			x4 = (x1 - x6) * t2 + x6;
			x5 = (x1 - x6) * t1 + x6;

			y2 = (y6 - y1) * t1 + y1;
			y3 = (y6 - y1) * t2 + y1;
			y4 = (y1 - y6) * t2 + y6;
			y5 = (y1 - y6) * t1 + y6;


			if (!par_multiscale) {
				placeCross(x3,y3,x4,y4);
				pushCross(level+1, x1,y2, x3,y5,0); // left
				pushCross(level+1, x4,y2, x6,y5,0); // right
				pushCross(level+1, x2,y4, x5,y6,0); // top
				pushCross(level+1, x2,y1, x5,y3,0); // bottom
			} else {
				placeCross(x3,y3,x4,y4);
				if (dir != 2)
					pushCross(level+1, x1,y2, x3,y5, 1); // left
				else
					placeWire(x1,(y2+y5)/2,x3,(y2+y5)/2);
				if (dir != 1)
					pushCross(level+1, x4,y2, x6,y5, 2); // right
				else
					placeWire(x4,(y2+y5)/2,x6,(y2+y5)/2);
				if (dir != 4) 
					pushCross(level+1, x2,y4, x5,y6, 3); // top
				else
					placeWire((x2+x5)/2, y4, (x2+x5)/2, y6);
				if (dir != 3) 
					pushCross(level+1, x2,y1, x5,y3, 4); // bottom
				else
					placeWire((x2+x5)/2, y1, (x2+x5)/2, y3);
			}

			//info += buildPoint(y1,y6);
			//info += buildPoint(0,y3);
			//info += "| ";
		}
	}
}

void doit(void) {
	real shift = max(par_connector_length - max(par_width, par_height)/2.0, 0);

	setPadding(par_padding);

	real orig_x = par_width / 2.0;
	real orig_y = par_height / 2.0;
	
	// if we're in the editor, place the origin at 
	// the connection pad
	if (!in_board_editor) {
		if(par_connect_to_center) {
			setOrigin(orig_x - shift, orig_y - shift);
		} else {
			setOrigin(orig_x, 0);
		}
	} else {
		setOrigin(-par_padding, -par_padding); // corner of the board
	}

	initEagle(par_trace_width, par_pad_diameter, par_pad_drill);
	buildAntenna();

	if (par_connect_to_center) {
		addConnection(orig_x+shift, orig_y+shift, 7, par_connector_length, 0, par_pad_diameter);
		if (par_add_dimensions) addDimensions(par_width+shift, par_height+shift);
	} else {
		addConnection(orig_x, par_connector_length, 0, par_connector_length, 0, par_pad_diameter);
		if (par_add_dimensions) addDimensions(par_width, par_height+par_connector_length);
	}
	exit (cmd);
}


// *** main ***

string con_points[] = {"center", "tip"};

// Show the config dialog
int n;
dlgDialog("Quadric Cross (Fraggi) Antenna") {
	dlgHBoxLayout {
		dlgVBoxLayout {
			dlgGridLayout {
				dlgCell(1, 1) dlgLabel("levels");
				dlgCell(1, 2) dlgIntEdit(par_levels, 1, 10);

				dlgCell(2, 1) dlgLabel("connection length (mm)");
				dlgCell(2, 2) dlgRealEdit(par_connector_length, 0, 100.0);

				dlgCell(3, 1) dlgLabel("connect to center");
				dlgCell(3, 2) dlgCheckBox("",par_connect_to_center);

				dlgCell(4, 1) dlgLabel("antenna width (mm)");
				dlgCell(4, 2) dlgRealEdit(par_width, 1.0,100.0);

				dlgCell(5, 1) dlgLabel("antenna height (mm)");
				dlgCell(5, 2) dlgRealEdit(par_height, 1.0,100.0);

				dlgCell(6, 1) dlgLabel("track width (mils)");
				dlgCell(6, 2) dlgRealEdit(par_trace_width, .1, 50.0);

				dlgCell(7, 1) dlgLabel("via/pad diameter (mm)");
				dlgCell(7, 2) dlgRealEdit(par_pad_diameter, .1, 10.0);

				dlgCell(8, 1) dlgLabel("via/pad drill (mm)");
				dlgCell(8, 2) dlgRealEdit(par_pad_drill, .1, 10.0);
			}
			dlgStretch(1);
		}
		dlgVBoxLayout {
			dlgGridLayout {
				if (in_board_editor) {
					dlgCell(1, 1) dlgLabel("board padding (mm)");
					dlgCell(1, 2) dlgRealEdit(par_padding, 1, 80.0);
					
					dlgCell(2, 1) dlgLabel("layer");
					dlgCell(2, 2) dlgIntEdit(layer, 1, 255);

					dlgCell(3, 1) dlgLabel("add board dimensions");
					dlgCell(3, 2) dlgCheckBox("", par_add_dimensions);
					n=3;
				} else {
					dlgCell(1, 1) dlgLabel("border padding (mm)");
					dlgCell(1, 2) dlgRealEdit(par_padding, 1, 80.0);

					dlgCell(2, 1) dlgLabel("add antenna border");
					dlgCell(2, 2) dlgCheckBox("", par_add_dimensions);
					n=2;
				}

				n++;
				dlgCell(n, 1) dlgLabel("multi-scale");
				dlgCell(n, 2) dlgCheckBox("", par_multiscale);

				n++;
				dlgCell(n, 1) dlgLabel("split ratio");
				dlgCell(n, 2) dlgRealEdit(par_split_ratio, 0, 1);
			}
			dlgStretch(1);
		}
  }
  dlgHBoxLayout {
	 dlgPushButton("+&OK")	  { dlgAccept(); doit(); }
	 dlgPushButton("-&Cancel") { dlgReject(); exit(0); }
	 dlgStretch(1);
  }
};



