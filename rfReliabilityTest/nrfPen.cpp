#include "Arduino.h"
#include "nrfPen.h"
    
      int role =0;    //Role 0 is recieve (default)
      byte nodeAddresses[2][6] = { {ADDRESS1} , {ADDRESS2} };              // Radio pipe addresses for the 2 nodes to communicate.
      uint32_t configTimer = millis();
      rf24_datarate_e default_DataRate = RF24_1MBPS;
static RF24 *node;      
      
/****************** Radio Config and failure detection ***************************/
nrfPen::nrfPen(RF24 *myradio){
  node=myradio; 
     
}

void nrfPen::init(bool waitForSerial=true){
  node->begin();                           //turn on node
  
  
  node->setPALevel(PWR_LVL);           // RF24_PA_MIN ,RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX (default)
  //NOTE: the rfMicro can handle up to PA_HIGH but more power is NOT always better, if your devices are in close proximity, transmission will fail if you set this too high regardless of whether the micro is actually supplying the needed power
  
  node->setDataRate( default_DataRate );      // RF24_250KBPS, RF24_1MBPS, RF24_2MBPS NOTE: NRF24L01 does not support 250KBPS, only the NRF24(+) does that, all the ones we have are (+) modules except some of the rf micros
  node->setChannel(CHANNEL);        //channel and address are not the same!!! Channel is 1MHz bands from 2.4-2.56GHz
  node->enableAckPayload();               // Allow optional ack payloads
  node->setRetries(10,10);                 // Smallest time between retries, max no. of retries
  if (waitForSerial){while(!Serial); }
  openPipes();
}

void nrfPen::openPipes(){
  if (role){        
    node->openWritingPipe(nodeAddresses[1]);   //this nodes writing pipe corresponds to the other nodes reading pipe!
    node->openReadingPipe(1,nodeAddresses[0]);    //same with reading pipe
    Serial.println("TRANSMITTER");
  } else { 
    node->openWritingPipe(nodeAddresses[0]);   //this nodes writing pipe corresponds to the other nodes reading pipe!
    node->openReadingPipe(1,nodeAddresses[1]);    //same with reading pipe  
    node->startListening();
    Serial.println("RECEIVER");
    node->writeAckPayload(1, DEF_ACK, sizeof(char));
  }

}

void nrfPen::checkForRadioFail(){
  
  if(node->failureDetected){
      node->failureDetected = false;
      delay(250);
      Serial.println("Radio failure detected, restarting node");
      init(false);        
  } 
  //Every 5 seconds, verify the configuration of the node. This can be done using any 
  //setting that is different from the node defaults.
  if(millis() - configTimer > 5000){
    configTimer = millis();
    if(node->getDataRate() != default_DataRate){
      node->failureDetected = true;
      Serial.print("Radio configuration error detected");
    }
  }
}

  /****************** Change Roles via Serial Commands ***************************/
void nrfPen::checkRole(){
  if ( Serial.available() )
  {
    char c = toupper(Serial.read());
    if ( c == 'T' && role == 0 ){      
      Serial.println(F("*** CHANGING TO TRANSMIT ROLE -- PRESS 'R' TO SWITCH BACK"));
      node->openWritingPipe(nodeAddresses[1]);   
      node->openReadingPipe(1,nodeAddresses[0]);    
      role = 1;                  // Become the primary transmitter 
    
   }else
    if ( c == 'R' && role == 1 ){
      Serial.println(F("*** CHANGING TO RECEIVE ROLE -- PRESS 'T' TO SWITCH BACK"));      
       role = 0;                // Become the primary receiver 
       node->startListening();
    }
    openPipes();
  }
}

int nrfPen::getRole(){
  int myRole = role;
  return myRole;
}
