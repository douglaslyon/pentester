#include <SPI.h>
#include <RF24.h>
#include <printf.h>   // must include this to use radio.printDetails();

#define CE_PIN 8
#define CSN_PIN 7

//NOTE: this ONLY tests rf transmission, delays and for missed packets. It does not include the keyboard functionality 
//(when using the keyboard functionality on reciever side you cannot send packets this fast, keyboard functions need delays and thus more time to execute)


RF24 radio(CE_PIN, CSN_PIN);
  const byte nodeAddresses[2][6] = { {"Node1"} , {"Node2"} };              // Radio pipe addresses for the 2 nodes to communicate.

              int sendCount=0;
              int rxCnt = 1;
              const uint8_t channel = 0x76;
              const int loadSize = 32;
              bool newLoad = false;
              byte inload[loadSize];
              byte outload[loadSize]= {'a', 'b', 'c', 'd','a', 'b', 'c', 'd','a', 'b', 'c', 'd','a', 'b', 'c', 'd'} ; //random array of 16 bytes for testing why not
              String com;
              bool radioNumber=0;       //THIS MUST BE CHANGED 0 FOR ONE NODE 1 FOR THE OTHER


void readAndReply() {
  radio.writeAckPayload(1, &rxCnt, sizeof(int));
  // check for radio message and send confirm using auto-ack, note you do not need to close your reading pipe/open writing to send an ack
  if ( radio.available() ) {
    radio.read( &inload, sizeof(inload) );
    rxCnt++;
    newLoad = true;
    delay(10);
  }
}

void transmitData(){
  byte gotAck;
  bool tx_sent = radio.write(&outload, sizeof(outload));
      if (tx_sent) {
        if (radio.isAckPayloadAvailable()) {
          radio.read(&gotAck, sizeof(gotAck));         // read ack payload and copy data to relevant remoteNodeData array 
                Serial.print("[+] Ack: ");
                Serial.println(gotAck);
                newLoad = false;
                sendCount++;
                Serial.print("Send Count #");
                Serial.print(sendCount);
                Serial.print(" || round trip(uS): ");
                
       } else Serial.println("No Ack payload recieved");
     } else {
            Serial.println("[-] The transmission failed.");
     }

}



void radioConnect(){
  radio.setPALevel(RF24_PA_HIGH);           // RF24_PA_MIN ,RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX (default)
  radio.setDataRate( RF24_1MBPS );      // RF24_250KBPS, RF24_1MBPS, RF24_2MBPS NOTE: NRF24L01 does not support 250KBPS, only the NRF24(+) does that, all the ones we have are (+) modules except the rf micros
  radio.setChannel(channel);        //channel and address are not the same!!! Channel is 1MHz bands from 2.4-2.56GHz
  radio.enableAckPayload();               // Allow optional ack payloads
  //radio.setRetries(5,10);                 // Smallest time between retries, max no. of retries
              
  radio.openWritingPipe(nodeAddresses[radioNumber]);   //this nodes writing pipe corresponds to the other nodes reading pipe!
    int addrb= !radioNumber;
  radio.openReadingPipe(1,nodeAddresses[addrb]);    //same with reading pipe
  radio.startListening();               //have to start listening to recieve, stop listening to transmit
  radio.printDetails();       //radio configuration, need to uncomment printf.begin() in setup as well

}


void setup(){
  Serial.begin(115200);
  printf_begin();                               // This is for initializing printf that is used by printDetails()
  while(!Serial);                             //Will skip first few print statements on rfMicro or 32u4 if you do not have this
  
  radio.begin();                           //turn on radio
  radioConnect();                   
  Serial.println("connecting................");
  Serial.println("--------------------------------------------------------"); 
}   

                                                                                               

void loop() {
    if (newLoad==true){
      unsigned long startMicros = micros();
      radio.stopListening();
      transmitData();
      radio.startListening();
      Serial.println(micros()-startMicros);
      //Serial.println(String((char*)outload));
      Serial.println("--------------------------------------------------------");
    }
}
