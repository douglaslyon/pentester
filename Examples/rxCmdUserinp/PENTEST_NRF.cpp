#include "Arduino.h"
#include "PENTEST_NRF.h"

/****************** Radio Variables ***********************************************/
static RF24 *node;     
      int role =0;    //Role 0 is recieve (default)
      uint32_t configTimer = millis();
      int channel = 0x76;
      
      unsigned long sendCount=0;
      unsigned long rxCnt = 0;
      unsigned long failCount=0;
      bool txNewLoad = false;
/****************** Radio Config and failure detection ***************************/
PENTEST_NRF::PENTEST_NRF(RF24 *myradio){
  node=myradio; 
   
}

void PENTEST_NRF::init(bool waitForSerial=true){
  node->setPALevel(default_DataRate);           // RF24_PA_MIN ,RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX (default)
  //NOTE: the rfMicro can handle up to PA_HIGH but more power is NOT always better, if your devices are in close proximity, transmission will fail if you set this too high regardless of whether the micro is actually supplying the needed power
  
  node->setDataRate( default_DataRate );      // RF24_250KBPS, RF24_1MBPS, RF24_2MBPS NOTE: NRF24L01 does not support 250KBPS, only the NRF24(+) does that, all the ones we have are (+) modules except some of the rf micros
  node->setChannel(channel);        //channel and address are not the same!!! Channel is 1MHz bands from 2.4-2.56GHz
  node->enableAckPayload();               // Allow optional ack payloads
  node->setRetries(10,10);                 // Smallest time between retries, max no. of retries
  if (waitForSerial){while(!Serial); }
  openPipes();
}

void PENTEST_NRF::openPipes(){
  if (role){        
    node->openWritingPipe(nodeAddresses[1]);   //this nodes writing pipe corresponds to the other nodes reading pipe!
    node->openReadingPipe(1,nodeAddresses[0]);    //same with reading pipe
    Serial.println("TRANSMITTER");
  } else { 
    node->openWritingPipe(nodeAddresses[0]);   //this nodes writing pipe corresponds to the other nodes reading pipe!
    node->openReadingPipe(1,nodeAddresses[1]);    //same with reading pipe  
    node->startListening();
    Serial.println("RECEIVER");
    node->writeAckPayload(1, DEF_ACK, sizeof(char));
  }

}

void PENTEST_NRF::checkForRadioFail(){
  
  if(node->failureDetected){
      node->failureDetected = false;
      delay(250);
      Serial.println("Radio failure detected, restarting node");
      init(false);        
  } 
  //Every 5 seconds, verify the configuration of the node. This can be done using any 
  //setting that is different from the node defaults.
  if(millis() - configTimer > 5000){
    configTimer = millis();
    if(node->getDataRate() != default_DataRate){
      node->failureDetected = true;
      Serial.print("Radio configuration error detected");
    }
  }
}

int PENTEST_NRF::getFailCount(int howOftenToPrint){
  ///if argument howOftenToPrint is = -1 then it will not print it, it will only return the failCount
  if (howOftenToPrint != -1 && sendCount % howOftenToPrint == 0 && sendCount > 0){
    Serial.print("\t-------\nThere have been ");
    Serial.print(failCount);
    Serial.print(" failures out of ");
    Serial.print(sendCount);
    Serial.println(" transmissions\n\t-------");    //Every n transmissions, print the number of failures
  }  
  return failCount;
}


  /****************** Change Roles via Serial Commands ***************************/
int PENTEST_NRF::checkRole(){
  if ( Serial.available() )
  {
    char c = toupper(Serial.read());
    if ( c == 'T' && role == 0 ){      
      Serial.println(F("*** CHANGING TO TRANSMIT ROLE -- PRESS 'R' TO SWITCH BACK"));
      node->openWritingPipe(nodeAddresses[1]);   
      node->openReadingPipe(1,nodeAddresses[0]);    
      role = 1;                  // Become the primary transmitter 
    
   }else
    if ( c == 'R' && role == 1 ){
      Serial.println(F("*** CHANGING TO RECEIVE ROLE -- PRESS 'T' TO SWITCH BACK"));      
       role = 0;                // Become the primary receiver 
       node->startListening();
    }
    openPipes();
  }
  return role;
}

  /****************** Radio Reliable send and recieve ***************************/
bool PENTEST_NRF::txReliable(byte outload[]){
  char gotAck;
  unsigned long startTime = micros();
  node->stopListening();
  bool tx_sent = node->write(&outload, sizeof(outload));
      if (tx_sent) {
        node->startListening();
        if (node->isAckPayloadAvailable()) {
          node->read(&gotAck, sizeof(gotAck));         // read ack payload and copy data   
                int tripTime = micros()-startTime;      
                sendCount++;   
                Serial.print("Sent packet ");
                Serial.print(sendCount);
                Serial.print(" || round trip (uS) ");
                Serial.println(tripTime);            
                Serial.print("[+] Acknowledgement Recieved:");
                Serial.println(gotAck);
                return true;
       } else {
           Serial.println(F("No Ack payload recieved"));
           return true;
       }
     } else {
            Serial.println(F("[-] The transmission failed."));
            if (sendCount != 0 ) {failCount++;}
            return false;
     }
}

bool PENTEST_NRF::rxReliable(byte inload[]) {
  // check for radio message and send confirm using auto-ack, note you do not need to close your reading pipe/open writing to send an ack
  while ( node->available() > 0) {
    node->read( &inload, sizeof(inload) );
    node->writeAckPayload(1, DEF_ACK, sizeof(DEF_ACK));
    if (inload[0]>0){ 
      rxCnt++;
      Serial.print("Package #");
      Serial.print(rxCnt);
      Serial.println(" received");
      return true;
    } else { 
      Serial.println("RX packet loss");
      return false;
    }
  }
  return false;
}

bool PENTEST_NRF::getInput(byte outload[], int loadSize){
  static bool rcvInProgress = false;
  static int ndx = 0;
  byte startMarker = '[';
  byte endMarker = ']';
  byte rb;
while (Serial.available() > 0 && txNewLoad == false) {
        rb = Serial.read();
         
  if (rcvInProgress == true){
        if (rb != endMarker) {
            outload[ndx] = rb;
            if (outload[ndx] != startMarker) { ndx++;}
            if (ndx >= loadSize) {
                ndx = loadSize - 1;
            }
        } else {
            outload[ndx] = '\0'; // terminate the string
            ndx = 0; 
            txNewLoad=true;           
            return true;
        }
    }else if (rb == startMarker ) {
      rcvInProgress = true;
    }
 }
 txNewLoad=false;
 return false;
}
