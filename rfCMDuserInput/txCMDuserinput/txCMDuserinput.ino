#include <SPI.h>
#include <RF24.h>
#include <printf.h>   // must include this to use radio.printDetails();

#define CE_PIN 8
#define CSN_PIN 7

RF24 radio(CE_PIN, CSN_PIN);
  const byte nodeAddresses[2][6] = { {"Node1"} , {"Node2"} };              // Radio pipe addresses for the 2 nodes to communicate.

              int sendCount=0;
              const uint8_t channel = 0x76;
              const int loadSize = 32;
              bool newLoad = false;
              //byte inload[loadSize];
              byte outload[loadSize];
              String com;

void setup(){
  Serial.begin(115200);
  printf_begin();                               // This is for initializing printf that is used by printDetails()
  while(!Serial);                             //Will skip first few print statements on rfMicro or 32u4 if you do not have this
  
  radio.begin();                           //turn on radio
  radioConnect();    
  radio.stopListening();               
  Serial.println("connecting................");
  Serial.println("Please type the commands you would like to send surrounded by brackets []");
  Serial.println("--------------------------------------------------------"); 
}   

                                                                                               

void loop() {
    getInput();
    if (newLoad==true){
      transmitData();
      Serial.print("Acknowledgement #");
      Serial.print(sendCount);
      Serial.print(" || ");
      Serial.println(String((char*)outload));
      Serial.println("--------------------------------------------------------");
    }
}




void getInput(){
  static bool rcvInProgress = false;
  static int ndx = 0;
  byte startMarker = '[';
  byte endMarker = ']';
  byte rb;
while (Serial.available() > 0 && newLoad == false) {
        rb = Serial.read();
         
  if (rcvInProgress == true){
        if (rb != endMarker) {
            outload[ndx] = rb;
            if (outload[ndx] != startMarker) { ndx++;}
            if (ndx >= loadSize) {
                ndx = loadSize - 1;
            }
        } else {
            outload[ndx] = '\0'; // terminate the string
            ndx = 0;            
            newLoad = true;
            
        }
    }else if (rb == startMarker ) {
      rcvInProgress = true;
    }
 }
}


void transmitData(){
  byte gotAck;
  bool tx_sent = radio.write(&outload, sizeof(outload));
      if (tx_sent) {
        if (radio.isAckPayloadAvailable()) {
          radio.read(&gotAck, sizeof(gotAck));         // read ack payload and copy data to relevant remoteNodeData array 
                Serial.print("[+] Delivered: ");
                Serial.println(gotAck);
                newLoad = false;
                sendCount++;
       } else Serial.println("No Ack payload recieved");
     } else {
            Serial.println("[-] The transmission failed.");
     }

}



void radioConnect(){
  radio.setPALevel(RF24_PA_HIGH);           // RF24_PA_MIN ,RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX (default)
  radio.setDataRate( RF24_1MBPS );      // RF24_250KBPS, RF24_1MBPS, RF24_2MBPS NOTE: NRF24L01 does not support 250KBPS, only the NRF24(+) does that, all the ones we have are (+) modules except the rf micros
  radio.setChannel(channel);        //channel and address are not the same!!! Channel is 1MHz bands from 2.4-2.56GHz
  radio.enableAckPayload();               // Allow optional ack payloads
  //radio.setRetries(5,10);                 // Smallest time between retries, max no. of retries
              
  radio.openWritingPipe(nodeAddresses[0]);   //this nodes writing pipe corresponds to the other nodes reading pipe!
  radio.openReadingPipe(1,nodeAddresses[1]);    //same with reading pipe
  radio.startListening();               //have to start listening to recieve, stop listening to transmit
  radio.printDetails();       //radio configuration, need to uncomment printf.begin() in setup as well

}
